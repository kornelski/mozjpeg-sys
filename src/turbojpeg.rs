/* automatically generated by rust-bindgen */

pub const TJ_NUMSAMP: u32 = 6;
pub const TJ_NUMPF: u32 = 12;
pub const TJ_NUMCS: u32 = 5;
pub const TJFLAG_BOTTOMUP: u32 = 2;
pub const TJFLAG_FASTUPSAMPLE: u32 = 256;
pub const TJFLAG_NOREALLOC: u32 = 1024;
pub const TJFLAG_FASTDCT: u32 = 2048;
pub const TJFLAG_ACCURATEDCT: u32 = 4096;
pub const TJFLAG_STOPONWARNING: u32 = 8192;
pub const TJFLAG_PROGRESSIVE: u32 = 16384;
pub const TJ_NUMERR: u32 = 2;
pub const TJ_NUMXOP: u32 = 8;
pub const TJXOPT_PERFECT: u32 = 1;
pub const TJXOPT_TRIM: u32 = 2;
pub const TJXOPT_CROP: u32 = 4;
pub const TJXOPT_GRAY: u32 = 8;
pub const TJXOPT_NOOUTPUT: u32 = 16;
pub const TJXOPT_PROGRESSIVE: u32 = 32;
pub const TJXOPT_COPYNONE: u32 = 64;
pub const TJFLAG_FORCEMMX: u32 = 8;
pub const TJFLAG_FORCESSE: u32 = 16;
pub const TJFLAG_FORCESSE2: u32 = 32;
pub const TJFLAG_FORCESSE3: u32 = 128;
pub const NUMSUBOPT: u32 = 6;
pub const TJ_BGR: u32 = 1;
pub const TJ_BOTTOMUP: u32 = 2;
pub const TJ_FORCEMMX: u32 = 8;
pub const TJ_FORCESSE: u32 = 16;
pub const TJ_FORCESSE2: u32 = 32;
pub const TJ_ALPHAFIRST: u32 = 64;
pub const TJ_FORCESSE3: u32 = 128;
pub const TJ_FASTUPSAMPLE: u32 = 256;
pub const TJ_YUV: u32 = 512;
#[doc = " 4:4:4 chrominance subsampling (no chrominance subsampling).  The JPEG or"]
#[doc = " YUV image will contain one chrominance component for every pixel in the"]
#[doc = " source image."]
pub const TJSAMP_TJSAMP_444: TJSAMP = 0;
#[doc = " 4:2:2 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 2x1 block of pixels in the source image."]
pub const TJSAMP_TJSAMP_422: TJSAMP = 1;
#[doc = " 4:2:0 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 2x2 block of pixels in the source image."]
pub const TJSAMP_TJSAMP_420: TJSAMP = 2;
#[doc = " Grayscale.  The JPEG or YUV image will contain no chrominance components."]
pub const TJSAMP_TJSAMP_GRAY: TJSAMP = 3;
#[doc = " 4:4:0 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 1x2 block of pixels in the source image."]
#[doc = ""]
#[doc = " @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_440: TJSAMP = 4;
#[doc = " 4:1:1 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 4x1 block of pixels in the source image."]
#[doc = " JPEG images compressed with 4:1:1 subsampling will be almost exactly the"]
#[doc = " same size as those compressed with 4:2:0 subsampling, and in the"]
#[doc = " aggregate, both subsampling methods produce approximately the same"]
#[doc = " perceptual quality.  However, 4:1:1 is better able to reproduce sharp"]
#[doc = " horizontal features."]
#[doc = ""]
#[doc = " @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_411: TJSAMP = 5;
#[doc = " Chrominance subsampling options."]
#[doc = " When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK"]
#[doc = " to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of"]
#[doc = " the Cb and Cr (chrominance) components can be discarded or averaged together"]
#[doc = " to produce a smaller image with little perceptible loss of image clarity"]
#[doc = " (the human eye is more sensitive to small changes in brightness than to"]
#[doc = " small changes in color.)  This is called \"chrominance subsampling\"."]
pub type TJSAMP = u32;
extern "C" {
    pub static mut tjMCUWidth: [::std::os::raw::c_int; 6usize];
}
extern "C" {
    pub static mut tjMCUHeight: [::std::os::raw::c_int; 6usize];
}
#[doc = " RGB pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 3-byte pixels in the order R, G, B from lowest to highest byte"]
#[doc = " address within each pixel."]
pub const TJPF_TJPF_RGB: TJPF = 0;
#[doc = " BGR pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 3-byte pixels in the order B, G, R from lowest to highest byte"]
#[doc = " address within each pixel."]
pub const TJPF_TJPF_BGR: TJPF = 1;
#[doc = " RGBX pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-byte pixels in the order R, G, B from lowest to highest byte"]
#[doc = " address within each pixel.  The X component is ignored when compressing"]
#[doc = " and undefined when decompressing."]
pub const TJPF_TJPF_RGBX: TJPF = 2;
#[doc = " BGRX pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-byte pixels in the order B, G, R from lowest to highest byte"]
#[doc = " address within each pixel.  The X component is ignored when compressing"]
#[doc = " and undefined when decompressing."]
pub const TJPF_TJPF_BGRX: TJPF = 3;
#[doc = " XBGR pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-byte pixels in the order R, G, B from highest to lowest byte"]
#[doc = " address within each pixel.  The X component is ignored when compressing"]
#[doc = " and undefined when decompressing."]
pub const TJPF_TJPF_XBGR: TJPF = 4;
#[doc = " XRGB pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-byte pixels in the order B, G, R from highest to lowest byte"]
#[doc = " address within each pixel.  The X component is ignored when compressing"]
#[doc = " and undefined when decompressing."]
pub const TJPF_TJPF_XRGB: TJPF = 5;
#[doc = " Grayscale pixel format.  Each 1-byte pixel represents a luminance"]
#[doc = " (brightness) level from 0 to 255."]
pub const TJPF_TJPF_GRAY: TJPF = 6;
#[doc = " RGBA pixel format.  This is the same as @ref TJPF_RGBX, except that when"]
#[doc = " decompressing, the X component is guaranteed to be 0xFF, which can be"]
#[doc = " interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_RGBA: TJPF = 7;
#[doc = " BGRA pixel format.  This is the same as @ref TJPF_BGRX, except that when"]
#[doc = " decompressing, the X component is guaranteed to be 0xFF, which can be"]
#[doc = " interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_BGRA: TJPF = 8;
#[doc = " ABGR pixel format.  This is the same as @ref TJPF_XBGR, except that when"]
#[doc = " decompressing, the X component is guaranteed to be 0xFF, which can be"]
#[doc = " interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ABGR: TJPF = 9;
#[doc = " ARGB pixel format.  This is the same as @ref TJPF_XRGB, except that when"]
#[doc = " decompressing, the X component is guaranteed to be 0xFF, which can be"]
#[doc = " interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ARGB: TJPF = 10;
#[doc = " CMYK pixel format.  Unlike RGB, which is an additive color model used"]
#[doc = " primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive"]
#[doc = " color model used primarily for printing.  In the CMYK color model, the"]
#[doc = " value of each color component typically corresponds to an amount of cyan,"]
#[doc = " magenta, yellow, or black ink that is applied to a white background.  In"]
#[doc = " order to convert between CMYK and RGB, it is necessary to use a color"]
#[doc = " management system (CMS.)  A CMS will attempt to map colors within the"]
#[doc = " printer's gamut to perceptually similar colors in the display's gamut and"]
#[doc = " vice versa, but the mapping is typically not 1:1 or reversible, nor can it"]
#[doc = " be defined with a simple formula.  Thus, such a conversion is out of scope"]
#[doc = " for a codec library.  However, the TurboJPEG API allows for compressing"]
#[doc = " CMYK pixels into a YCCK JPEG image (see #TJCS_YCCK) and decompressing YCCK"]
#[doc = " JPEG images into CMYK pixels."]
pub const TJPF_TJPF_CMYK: TJPF = 11;
#[doc = " Unknown pixel format.  Currently this is only used by #tjLoadImage()."]
pub const TJPF_TJPF_UNKNOWN: TJPF = -1;
#[doc = " Pixel formats"]
pub type TJPF = i32;
extern "C" {
    pub static mut tjRedOffset: [::std::os::raw::c_int; 12usize];
}
extern "C" {
    pub static mut tjGreenOffset: [::std::os::raw::c_int; 12usize];
}
extern "C" {
    pub static mut tjBlueOffset: [::std::os::raw::c_int; 12usize];
}
extern "C" {
    pub static mut tjAlphaOffset: [::std::os::raw::c_int; 12usize];
}
extern "C" {
    pub static mut tjPixelSize: [::std::os::raw::c_int; 12usize];
}
#[doc = " RGB colorspace.  When compressing the JPEG image, the R, G, and B"]
#[doc = " components in the source image are reordered into image planes, but no"]
#[doc = " colorspace conversion or subsampling is performed.  RGB JPEG images can be"]
#[doc = " decompressed to any of the extended RGB pixel formats or grayscale, but"]
#[doc = " they cannot be decompressed to YUV images."]
pub const TJCS_TJCS_RGB: TJCS = 0;
#[doc = " YCbCr colorspace.  YCbCr is not an absolute colorspace but rather a"]
#[doc = " mathematical transformation of RGB designed solely for storage and"]
#[doc = " transmission.  YCbCr images must be converted to RGB before they can"]
#[doc = " actually be displayed.  In the YCbCr colorspace, the Y (luminance)"]
#[doc = " component represents the black & white portion of the original image, and"]
#[doc = " the Cb and Cr (chrominance) components represent the color portion of the"]
#[doc = " original image.  Originally, the analog equivalent of this transformation"]
#[doc = " allowed the same signal to drive both black & white and color televisions,"]
#[doc = " but JPEG images use YCbCr primarily because it allows the color data to be"]
#[doc = " optionally subsampled for the purposes of reducing bandwidth or disk"]
#[doc = " space.  YCbCr is the most common JPEG colorspace, and YCbCr JPEG images"]
#[doc = " can be compressed from and decompressed to any of the extended RGB pixel"]
#[doc = " formats or grayscale, or they can be decompressed to YUV planar images."]
pub const TJCS_TJCS_YCbCr: TJCS = 1;
#[doc = " Grayscale colorspace.  The JPEG image retains only the luminance data (Y"]
#[doc = " component), and any color data from the source image is discarded."]
#[doc = " Grayscale JPEG images can be compressed from and decompressed to any of"]
#[doc = " the extended RGB pixel formats or grayscale, or they can be decompressed"]
#[doc = " to YUV planar images."]
pub const TJCS_TJCS_GRAY: TJCS = 2;
#[doc = " CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K"]
#[doc = " components in the source image are reordered into image planes, but no"]
#[doc = " colorspace conversion or subsampling is performed.  CMYK JPEG images can"]
#[doc = " only be decompressed to CMYK pixels."]
pub const TJCS_TJCS_CMYK: TJCS = 3;
#[doc = " YCCK colorspace.  YCCK (AKA \"YCbCrK\") is not an absolute colorspace but"]
#[doc = " rather a mathematical transformation of CMYK designed solely for storage"]
#[doc = " and transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be"]
#[doc = " reversibly transformed into YCCK, and as with YCbCr, the chrominance"]
#[doc = " components in the YCCK pixels can be subsampled without incurring major"]
#[doc = " perceptual loss.  YCCK JPEG images can only be compressed from and"]
#[doc = " decompressed to CMYK pixels."]
pub const TJCS_TJCS_YCCK: TJCS = 4;
#[doc = " JPEG colorspaces"]
pub type TJCS = u32;
#[doc = " The error was non-fatal and recoverable, but the image may still be"]
#[doc = " corrupt."]
pub const TJERR_TJERR_WARNING: TJERR = 0;
#[doc = " The error was fatal and non-recoverable."]
pub const TJERR_TJERR_FATAL: TJERR = 1;
#[doc = " Error codes"]
pub type TJERR = u32;
#[doc = " Do not transform the position of the image pixels"]
pub const TJXOP_TJXOP_NONE: TJXOP = 0;
#[doc = " Flip (mirror) image horizontally.  This transform is imperfect if there"]
#[doc = " are any partial MCU blocks on the right edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_HFLIP: TJXOP = 1;
#[doc = " Flip (mirror) image vertically.  This transform is imperfect if there are"]
#[doc = " any partial MCU blocks on the bottom edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_VFLIP: TJXOP = 2;
#[doc = " Transpose image (flip/mirror along upper left to lower right axis.)  This"]
#[doc = " transform is always perfect."]
pub const TJXOP_TJXOP_TRANSPOSE: TJXOP = 3;
#[doc = " Transverse transpose image (flip/mirror along upper right to lower left"]
#[doc = " axis.)  This transform is imperfect if there are any partial MCU blocks in"]
#[doc = " the image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_TRANSVERSE: TJXOP = 4;
#[doc = " Rotate image clockwise by 90 degrees.  This transform is imperfect if"]
#[doc = " there are any partial MCU blocks on the bottom edge (see"]
#[doc = " #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT90: TJXOP = 5;
#[doc = " Rotate image 180 degrees.  This transform is imperfect if there are any"]
#[doc = " partial MCU blocks in the image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT180: TJXOP = 6;
#[doc = " Rotate image counter-clockwise by 90 degrees.  This transform is imperfect"]
#[doc = " if there are any partial MCU blocks on the right edge (see"]
#[doc = " #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT270: TJXOP = 7;
#[doc = " Transform operations for #tjTransform()"]
pub type TJXOP = u32;
#[doc = " Scaling factor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjscalingfactor {
    #[doc = " Numerator"]
    pub num: ::std::os::raw::c_int,
    #[doc = " Denominator"]
    pub denom: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tjscalingfactor() {
    assert_eq!(
        ::std::mem::size_of::<tjscalingfactor>(),
        8usize,
        concat!("Size of: ", stringify!(tjscalingfactor))
    );
    assert_eq!(
        ::std::mem::align_of::<tjscalingfactor>(),
        4usize,
        concat!("Alignment of ", stringify!(tjscalingfactor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjscalingfactor>())).num as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(tjscalingfactor),
        "::",
        stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjscalingfactor>())).denom as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(tjscalingfactor),
        "::",
        stringify!(denom)
        )
    );
}
#[doc = " Cropping region"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjregion {
    #[doc = " The left boundary of the cropping region.  This must be evenly divisible"]
    #[doc = " by the MCU block width (see #tjMCUWidth.)"]
    pub x: ::std::os::raw::c_int,
    #[doc = " The upper boundary of the cropping region.  This must be evenly divisible"]
    #[doc = " by the MCU block height (see #tjMCUHeight.)"]
    pub y: ::std::os::raw::c_int,
    #[doc = " The width of the cropping region. Setting this to 0 is the equivalent of"]
    #[doc = " setting it to the width of the source JPEG image - x."]
    pub w: ::std::os::raw::c_int,
    #[doc = " The height of the cropping region. Setting this to 0 is the equivalent of"]
    #[doc = " setting it to the height of the source JPEG image - y."]
    pub h: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tjregion() {
    assert_eq!(
        ::std::mem::size_of::<tjregion>(),
        16usize,
        concat!("Size of: ", stringify!(tjregion))
    );
    assert_eq!(
        ::std::mem::align_of::<tjregion>(),
        4usize,
        concat!("Alignment of ", stringify!(tjregion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjregion>())).x as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(tjregion),
        "::",
        stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjregion>())).y as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(tjregion),
        "::",
        stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjregion>())).w as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(tjregion),
        "::",
        stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjregion>())).h as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(tjregion),
        "::",
        stringify!(h)
        )
    );
}
#[doc = " Lossless transform"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjtransform {
    #[doc = " Cropping region"]
    pub r: tjregion,
    #[doc = " One of the @ref TJXOP \"transform operations\""]
    pub op: ::std::os::raw::c_int,
    #[doc = " The bitwise OR of one of more of the @ref TJXOPT_CROP \"transform options\""]
    pub options: ::std::os::raw::c_int,
    #[doc = " Arbitrary data that can be accessed within the body of the callback"]
    #[doc = " function"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " A callback function that can be used to modify the DCT coefficients"]
    #[doc = " after they are losslessly transformed but before they are transcoded to a"]
    #[doc = " new JPEG image.  This allows for custom filters or other transformations"]
    #[doc = " to be applied in the frequency domain."]
    #[doc = ""]
    #[doc = " @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:"]
    #[doc = " this pointer is not guaranteed to be valid once the callback returns, so"]
    #[doc = " applications wishing to hand off the DCT coefficients to another function"]
    #[doc = " or library should make a copy of them within the body of the callback.)"]
    #[doc = ""]
    #[doc = " @param arrayRegion #tjregion structure containing the width and height of"]
    #[doc = " the array pointed to by <tt>coeffs</tt> as well as its offset relative to"]
    #[doc = " the component plane.  TurboJPEG implementations may choose to split each"]
    #[doc = " component plane into multiple DCT coefficient arrays and call the callback"]
    #[doc = " function once for each array."]
    #[doc = ""]
    #[doc = " @param planeRegion #tjregion structure containing the width and height of"]
    #[doc = " the component plane to which <tt>coeffs</tt> belongs"]
    #[doc = ""]
    #[doc = " @param componentID ID number of the component plane to which"]
    #[doc = " <tt>coeffs</tt> belongs (Y, Cb, and Cr have, respectively, ID's of 0, 1,"]
    #[doc = " and 2 in typical JPEG images.)"]
    #[doc = ""]
    #[doc = " @param transformID ID number of the transformed image to which"]
    #[doc = " <tt>coeffs</tt> belongs.  This is the same as the index of the transform"]
    #[doc = " in the <tt>transforms</tt> array that was passed to #tjTransform()."]
    #[doc = ""]
    #[doc = " @param transform a pointer to a #tjtransform structure that specifies the"]
    #[doc = " parameters and/or cropping region for this transform"]
    #[doc = ""]
    #[doc = " @return 0 if the callback was successful, or -1 if an error occurred."]
    pub customFilter: ::std::option::Option<
        unsafe extern "C" fn(
            coeffs: *mut ::std::os::raw::c_short,
            arrayRegion: tjregion,
            planeRegion: tjregion,
            componentIndex: ::std::os::raw::c_int,
            transformIndex: ::std::os::raw::c_int,
            transform: *mut tjtransform,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_tjtransform() {
    assert_eq!(
        ::std::mem::size_of::<tjtransform>(),
        40usize,
        concat!("Size of: ", stringify!(tjtransform))
    );
    assert_eq!(
        ::std::mem::align_of::<tjtransform>(),
        8usize,
        concat!("Alignment of ", stringify!(tjtransform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjtransform>())).r as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(tjtransform),
        "::",
        stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjtransform>())).op as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(tjtransform),
        "::",
        stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjtransform>())).options as *const _ as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(tjtransform),
        "::",
        stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjtransform>())).data as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(tjtransform),
        "::",
        stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tjtransform>())).customFilter as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(tjtransform),
        "::",
        stringify!(customFilter)
        )
    );
}
#[doc = " TurboJPEG instance handle"]
pub type tjhandle = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " Create a TurboJPEG compressor instance."]
    #[doc = ""]
    #[doc = " @return a handle to the newly-created instance, or NULL if an error"]
    #[doc = " occurred (see #tjGetErrorStr2().)"]
    pub fn tjInitCompress() -> tjhandle;
}
extern "C" {
    #[doc = " Compress an RGB, grayscale, or CMYK image into a JPEG image."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to an image buffer containing RGB, grayscale, or"]
    #[doc = " CMYK pixels to be compressed"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch bytes per line in the source image.  Normally, this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or"]
    #[doc = " <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image"]
    #[doc = " is padded to the nearest 32-bit boundary, as is the case for Windows"]
    #[doc = " bitmaps.  You can also be clever and use this parameter to skip lines, etc."]
    #[doc = " Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to an image buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer"]
    #[doc = " to accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer"]
    #[doc = " for you, or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tjBufSize().  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your"]
    #[doc = " pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,"]
    #[doc = " you should always check <tt>*jpegBuf</tt> upon return from this function, as"]
    #[doc = " it may have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to an unsigned long variable that holds the size of"]
    #[doc = " the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated"]
    #[doc = " buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer."]
    #[doc = " Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in"]
    #[doc = " bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being"]
    #[doc = " reused from a previous call to one of the JPEG compression functions, then"]
    #[doc = " <tt>*jpegSize</tt> is ignored."]
    #[doc = ""]
    #[doc = " @param jpegSubsamp the level of chrominance subsampling to be used when"]
    #[doc = " generating the JPEG image (see @ref TJSAMP"]
    #[doc = " \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @param jpegQual the image quality of the generated JPEG image (1 = worst,"]
    #[doc = " 100 = best)"]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjCompress2(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut ::std::os::raw::c_ulong,
        jpegSubsamp: ::std::os::raw::c_int,
        jpegQual: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compress a YUV planar image into a JPEG image."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to an image buffer containing a YUV planar image to be"]
    #[doc = " compressed.  The size of this buffer should match the value returned by"]
    #[doc = " #tjBufSizeYUV2() for the given image width, height, padding, and level of"]
    #[doc = " chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be"]
    #[doc = " stored sequentially in the source buffer (refer to @ref YUVnotes"]
    #[doc = " \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image.  If the width is not an"]
    #[doc = " even multiple of the MCU block width (see #tjMCUWidth), then an intermediate"]
    #[doc = " buffer copy will be performed within TurboJPEG."]
    #[doc = ""]
    #[doc = " @param pad the line padding used in the source image.  For instance, if each"]
    #[doc = " line in each plane of the YUV image is padded to the nearest multiple of 4"]
    #[doc = " bytes, then <tt>pad</tt> should be set to 4."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image.  If the height is not"]
    #[doc = " an even multiple of the MCU block height (see #tjMCUHeight), then an"]
    #[doc = " intermediate buffer copy will be performed within TurboJPEG."]
    #[doc = ""]
    #[doc = " @param subsamp the level of chrominance subsampling used in the source"]
    #[doc = " image (see @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to an image buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer"]
    #[doc = " for you, or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tjBufSize().  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your"]
    #[doc = " pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,"]
    #[doc = " you should always check <tt>*jpegBuf</tt> upon return from this function, as"]
    #[doc = " it may have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to an unsigned long variable that holds the size of"]
    #[doc = " the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated"]
    #[doc = " buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer."]
    #[doc = " Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in"]
    #[doc = " bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being"]
    #[doc = " reused from a previous call to one of the JPEG compression functions, then"]
    #[doc = " <tt>*jpegSize</tt> is ignored."]
    #[doc = ""]
    #[doc = " @param jpegQual the image quality of the generated JPEG image (1 = worst,"]
    #[doc = " 100 = best)"]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjCompressFromYUV(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pad: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut ::std::os::raw::c_ulong,
        jpegQual: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compress a set of Y, U (Cb), and V (Cr) image planes into a JPEG image."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if compressing a grayscale image) that contain a YUV"]
    #[doc = " image to be compressed.  These planes can be contiguous or non-contiguous in"]
    #[doc = " memory.  The size of each plane should match the value returned by"]
    #[doc = " #tjPlaneSizeYUV() for the given image width, height, strides, and level of"]
    #[doc = " chrominance subsampling.  Refer to @ref YUVnotes \"YUV Image Format Notes\""]
    #[doc = " for more details."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image.  If the width is not an"]
    #[doc = " even multiple of the MCU block width (see #tjMCUWidth), then an intermediate"]
    #[doc = " buffer copy will be performed within TurboJPEG."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " line in the corresponding plane of the YUV source image.  Setting the stride"]
    #[doc = " for any plane to 0 is the same as setting it to the plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If <tt>strides</tt> is NULL, then"]
    #[doc = " the strides for all planes will be set to their respective plane widths."]
    #[doc = " You can adjust the strides in order to specify an arbitrary amount of line"]
    #[doc = " padding in each plane or to create a JPEG image from a subregion of a larger"]
    #[doc = " YUV planar image."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image.  If the height is not"]
    #[doc = " an even multiple of the MCU block height (see #tjMCUHeight), then an"]
    #[doc = " intermediate buffer copy will be performed within TurboJPEG."]
    #[doc = ""]
    #[doc = " @param subsamp the level of chrominance subsampling used in the source"]
    #[doc = " image (see @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to an image buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer"]
    #[doc = " for you, or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tjBufSize().  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your"]
    #[doc = " pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,"]
    #[doc = " you should always check <tt>*jpegBuf</tt> upon return from this function, as"]
    #[doc = " it may have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to an unsigned long variable that holds the size of"]
    #[doc = " the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated"]
    #[doc = " buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer."]
    #[doc = " Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in"]
    #[doc = " bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being"]
    #[doc = " reused from a previous call to one of the JPEG compression functions, then"]
    #[doc = " <tt>*jpegSize</tt> is ignored."]
    #[doc = ""]
    #[doc = " @param jpegQual the image quality of the generated JPEG image (1 = worst,"]
    #[doc = " 100 = best)"]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjCompressFromYUVPlanes(
        handle: tjhandle,
        srcPlanes: *mut *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        strides: *const ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut ::std::os::raw::c_ulong,
        jpegQual: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The maximum size of the buffer (in bytes) required to hold a JPEG image with"]
    #[doc = " the given parameters.  The number of bytes returned by this function is"]
    #[doc = " larger than the size of the uncompressed source image.  The reason for this"]
    #[doc = " is that the JPEG format uses 16-bit coefficients, and it is thus possible"]
    #[doc = " for a very high-quality JPEG image with very high-frequency content to"]
    #[doc = " expand rather than compress when converted to the JPEG format.  Such images"]
    #[doc = " represent a very rare corner case, but since there is no way to predict the"]
    #[doc = " size of a JPEG image prior to compression, the corner case has to be"]
    #[doc = " handled."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param jpegSubsamp the level of chrominance subsampling to be used when"]
    #[doc = " generating the JPEG image (see @ref TJSAMP"]
    #[doc = " \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the maximum size of the buffer (in bytes) required to hold the"]
    #[doc = " image, or -1 if the arguments are out of bounds."]
    pub fn tjBufSize(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        jpegSubsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " The size of the buffer (in bytes) required to hold a YUV planar image with"]
    #[doc = " the given parameters."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param pad the width of each line in each plane of the image is padded to"]
    #[doc = " the nearest multiple of this number of bytes (must be a power of 2.)"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the size of the buffer (in bytes) required to hold the image, or"]
    #[doc = " -1 if the arguments are out of bounds."]
    pub fn tjBufSizeYUV2(
        width: ::std::os::raw::c_int,
        pad: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " The size of the buffer (in bytes) required to hold a YUV image plane with"]
    #[doc = " the given parameters."]
    #[doc = ""]
    #[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the YUV image.  NOTE: this is the width of"]
    #[doc = " the whole image, not the plane width."]
    #[doc = ""]
    #[doc = " @param stride bytes per line in the image plane.  Setting this to 0 is the"]
    #[doc = " equivalent of setting it to the plane width."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the YUV image.  NOTE: this is the height"]
    #[doc = " of the whole image, not the plane height."]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the size of the buffer (in bytes) required to hold the YUV image"]
    #[doc = " plane, or -1 if the arguments are out of bounds."]
    pub fn tjPlaneSizeYUV(
        componentID: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " The plane width of a YUV image plane with the given parameters.  Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\" for a description of plane width."]
    #[doc = ""]
    #[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the YUV image"]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the plane width of a YUV image plane with the given parameters, or"]
    #[doc = " -1 if the arguments are out of bounds."]
    pub fn tjPlaneWidth(
        componentID: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The plane height of a YUV image plane with the given parameters.  Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\" for a description of plane height."]
    #[doc = ""]
    #[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the YUV image"]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the plane height of a YUV image plane with the given parameters, or"]
    #[doc = " -1 if the arguments are out of bounds."]
    pub fn tjPlaneHeight(
        componentID: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode an RGB or grayscale image into a YUV planar image.  This function"]
    #[doc = " uses the accelerated color conversion routines in the underlying"]
    #[doc = " codec but does not execute any of the other steps in the JPEG compression"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to an image buffer containing RGB or grayscale pixels"]
    #[doc = " to be encoded"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch bytes per line in the source image.  Normally, this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or"]
    #[doc = " <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image"]
    #[doc = " is padded to the nearest 32-bit boundary, as is the case for Windows"]
    #[doc = " bitmaps.  You can also be clever and use this parameter to skip lines, etc."]
    #[doc = " Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to an image buffer that will receive the YUV image."]
    #[doc = " Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based"]
    #[doc = " on the image width, height, padding, and level of chrominance subsampling."]
    #[doc = " The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the"]
    #[doc = " buffer (refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param pad the width of each line in each plane of the YUV image will be"]
    #[doc = " padded to the nearest multiple of this number of bytes (must be a power of"]
    #[doc = " 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to"]
    #[doc = " 4."]
    #[doc = ""]
    #[doc = " @param subsamp the level of chrominance subsampling to be used when"]
    #[doc = " generating the YUV image (see @ref TJSAMP"]
    #[doc = " \"Chrominance subsampling options\".)  To generate images suitable for X"]
    #[doc = " Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an"]
    #[doc = " image compatible with the I420 (AKA \"YUV420P\") format."]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjEncodeYUV3(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        pad: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode an RGB or grayscale image into separate Y, U (Cb), and V (Cr) image"]
    #[doc = " planes.  This function uses the accelerated color conversion routines in the"]
    #[doc = " underlying codec but does not execute any of the other steps in the JPEG"]
    #[doc = " compression process."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to an image buffer containing RGB or grayscale pixels"]
    #[doc = " to be encoded"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch bytes per line in the source image.  Normally, this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or"]
    #[doc = " <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image"]
    #[doc = " is padded to the nearest 32-bit boundary, as is the case for Windows"]
    #[doc = " bitmaps.  You can also be clever and use this parameter to skip lines, etc."]
    #[doc = " Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if generating a grayscale image) that will receive the"]
    #[doc = " encoded image.  These planes can be contiguous or non-contiguous in memory."]
    #[doc = " Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based"]
    #[doc = " on the image width, height, strides, and level of chrominance subsampling."]
    #[doc = " Refer to @ref YUVnotes \"YUV Image Format Notes\" for more details."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " line in the corresponding plane of the output image.  Setting the stride for"]
    #[doc = " any plane to 0 is the same as setting it to the plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If <tt>strides</tt> is NULL, then"]
    #[doc = " the strides for all planes will be set to their respective plane widths."]
    #[doc = " You can adjust the strides in order to add an arbitrary amount of line"]
    #[doc = " padding to each plane or to encode an RGB or grayscale image into a"]
    #[doc = " subregion of a larger YUV planar image."]
    #[doc = ""]
    #[doc = " @param subsamp the level of chrominance subsampling to be used when"]
    #[doc = " generating the YUV image (see @ref TJSAMP"]
    #[doc = " \"Chrominance subsampling options\".)  To generate images suitable for X"]
    #[doc = " Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an"]
    #[doc = " image compatible with the I420 (AKA \"YUV420P\") format."]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjEncodeYUVPlanes(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        dstPlanes: *mut *mut ::std::os::raw::c_uchar,
        strides: *mut ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a TurboJPEG decompressor instance."]
    #[doc = ""]
    #[doc = " @return a handle to the newly-created instance, or NULL if an error"]
    #[doc = " occurred (see #tjGetErrorStr2().)"]
    pub fn tjInitDecompress() -> tjhandle;
}
extern "C" {
    #[doc = " Retrieve information about a JPEG image without decompressing it."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a buffer containing a JPEG image"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param width pointer to an integer variable that will receive the width (in"]
    #[doc = " pixels) of the JPEG image"]
    #[doc = ""]
    #[doc = " @param height pointer to an integer variable that will receive the height"]
    #[doc = " (in pixels) of the JPEG image"]
    #[doc = ""]
    #[doc = " @param jpegSubsamp pointer to an integer variable that will receive the"]
    #[doc = " level of chrominance subsampling used when the JPEG image was compressed"]
    #[doc = " (see @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @param jpegColorspace pointer to an integer variable that will receive one"]
    #[doc = " of the JPEG colorspace constants, indicating the colorspace of the JPEG"]
    #[doc = " image (see @ref TJCS \"JPEG colorspaces\".)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjDecompressHeader3(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        jpegSubsamp: *mut ::std::os::raw::c_int,
        jpegColorspace: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a list of fractional scaling factors that the JPEG decompressor in"]
    #[doc = " this implementation of TurboJPEG supports."]
    #[doc = ""]
    #[doc = " @param numscalingfactors pointer to an integer variable that will receive"]
    #[doc = " the number of elements in the list"]
    #[doc = ""]
    #[doc = " @return a pointer to a list of fractional scaling factors, or NULL if an"]
    #[doc = " error is encountered (see #tjGetErrorStr2().)"]
    pub fn tjGetScalingFactors(
        numscalingfactors: *mut ::std::os::raw::c_int,
    ) -> *mut tjscalingfactor;
}
extern "C" {
    #[doc = " Decompress a JPEG image to an RGB, grayscale, or CMYK image."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a buffer containing the JPEG image to decompress"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to an image buffer that will receive the decompressed"]
    #[doc = " image.  This buffer should normally be <tt>pitch * scaledHeight</tt> bytes"]
    #[doc = " in size, where <tt>scaledHeight</tt> can be determined by calling"]
    #[doc = " #TJSCALED() with the JPEG image height and one of the scaling factors"]
    #[doc = " returned by #tjGetScalingFactors().  The <tt>dstBuf</tt> pointer may also be"]
    #[doc = " used to decompress into a specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param width desired width (in pixels) of the destination image.  If this is"]
    #[doc = " different than the width of the JPEG image being decompressed, then"]
    #[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
    #[doc = " possible image that will fit within the desired width.  If <tt>width</tt> is"]
    #[doc = " set to 0, then only the height will be considered when determining the"]
    #[doc = " scaled image size."]
    #[doc = ""]
    #[doc = " @param pitch bytes per line in the destination image.  Normally, this is"]
    #[doc = " <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt> if the decompressed image"]
    #[doc = " is unpadded, else <tt>#TJPAD(scaledWidth * #tjPixelSize[pixelFormat])</tt>"]
    #[doc = " if each line of the decompressed image is padded to the nearest 32-bit"]
    #[doc = " boundary, as is the case for Windows bitmaps.  (NOTE: <tt>scaledWidth</tt>"]
    #[doc = " can be determined by calling #TJSCALED() with the JPEG image width and one"]
    #[doc = " of the scaling factors returned by #tjGetScalingFactors().)  You can also be"]
    #[doc = " clever and use the pitch parameter to skip lines, etc.  Setting this"]
    #[doc = " parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height desired height (in pixels) of the destination image.  If this"]
    #[doc = " is different than the height of the JPEG image being decompressed, then"]
    #[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
    #[doc = " possible image that will fit within the desired height.  If <tt>height</tt>"]
    #[doc = " is set to 0, then only the width will be considered when determining the"]
    #[doc = " scaled image size."]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the destination image (see @ref"]
    #[doc = " TJPF \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjDecompress2(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decompress a JPEG image to a YUV planar image.  This function performs JPEG"]
    #[doc = " decompression but leaves out the color conversion step, so a planar YUV"]
    #[doc = " image is generated instead of an RGB image."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a buffer containing the JPEG image to decompress"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to an image buffer that will receive the YUV image."]
    #[doc = " Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based"]
    #[doc = " on the image width, height, padding, and level of subsampling.  The Y,"]
    #[doc = " U (Cb), and V (Cr) image planes will be stored sequentially in the buffer"]
    #[doc = " (refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param width desired width (in pixels) of the YUV image.  If this is"]
    #[doc = " different than the width of the JPEG image being decompressed, then"]
    #[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
    #[doc = " possible image that will fit within the desired width.  If <tt>width</tt> is"]
    #[doc = " set to 0, then only the height will be considered when determining the"]
    #[doc = " scaled image size.  If the scaled width is not an even multiple of the MCU"]
    #[doc = " block width (see #tjMCUWidth), then an intermediate buffer copy will be"]
    #[doc = " performed within TurboJPEG."]
    #[doc = ""]
    #[doc = " @param pad the width of each line in each plane of the YUV image will be"]
    #[doc = " padded to the nearest multiple of this number of bytes (must be a power of"]
    #[doc = " 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to"]
    #[doc = " 4."]
    #[doc = ""]
    #[doc = " @param height desired height (in pixels) of the YUV image.  If this is"]
    #[doc = " different than the height of the JPEG image being decompressed, then"]
    #[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
    #[doc = " possible image that will fit within the desired height.  If <tt>height</tt>"]
    #[doc = " is set to 0, then only the width will be considered when determining the"]
    #[doc = " scaled image size.  If the scaled height is not an even multiple of the MCU"]
    #[doc = " block height (see #tjMCUHeight), then an intermediate buffer copy will be"]
    #[doc = " performed within TurboJPEG."]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjDecompressToYUV2(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pad: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decompress a JPEG image into separate Y, U (Cb), and V (Cr) image"]
    #[doc = " planes.  This function performs JPEG decompression but leaves out the color"]
    #[doc = " conversion step, so a planar YUV image is generated instead of an RGB image."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a buffer containing the JPEG image to decompress"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if decompressing a grayscale image) that will receive"]
    #[doc = " the YUV image.  These planes can be contiguous or non-contiguous in memory."]
    #[doc = " Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based"]
    #[doc = " on the scaled image width, scaled image height, strides, and level of"]
    #[doc = " chrominance subsampling.  Refer to @ref YUVnotes \"YUV Image Format Notes\""]
    #[doc = " for more details."]
    #[doc = ""]
    #[doc = " @param width desired width (in pixels) of the YUV image.  If this is"]
    #[doc = " different than the width of the JPEG image being decompressed, then"]
    #[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
    #[doc = " possible image that will fit within the desired width.  If <tt>width</tt> is"]
    #[doc = " set to 0, then only the height will be considered when determining the"]
    #[doc = " scaled image size.  If the scaled width is not an even multiple of the MCU"]
    #[doc = " block width (see #tjMCUWidth), then an intermediate buffer copy will be"]
    #[doc = " performed within TurboJPEG."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " line in the corresponding plane of the output image.  Setting the stride for"]
    #[doc = " any plane to 0 is the same as setting it to the scaled plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If <tt>strides</tt> is NULL, then"]
    #[doc = " the strides for all planes will be set to their respective scaled plane"]
    #[doc = " widths.  You can adjust the strides in order to add an arbitrary amount of"]
    #[doc = " line padding to each plane or to decompress the JPEG image into a subregion"]
    #[doc = " of a larger YUV planar image."]
    #[doc = ""]
    #[doc = " @param height desired height (in pixels) of the YUV image.  If this is"]
    #[doc = " different than the height of the JPEG image being decompressed, then"]
    #[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
    #[doc = " possible image that will fit within the desired height.  If <tt>height</tt>"]
    #[doc = " is set to 0, then only the width will be considered when determining the"]
    #[doc = " scaled image size.  If the scaled height is not an even multiple of the MCU"]
    #[doc = " block height (see #tjMCUHeight), then an intermediate buffer copy will be"]
    #[doc = " performed within TurboJPEG."]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjDecompressToYUVPlanes(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstPlanes: *mut *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        strides: *mut ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a YUV planar image into an RGB or grayscale image.  This function"]
    #[doc = " uses the accelerated color conversion routines in the underlying"]
    #[doc = " codec but does not execute any of the other steps in the JPEG decompression"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to an image buffer containing a YUV planar image to be"]
    #[doc = " decoded.  The size of this buffer should match the value returned by"]
    #[doc = " #tjBufSizeYUV2() for the given image width, height, padding, and level of"]
    #[doc = " chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be"]
    #[doc = " stored sequentially in the source buffer (refer to @ref YUVnotes"]
    #[doc = " \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param pad Use this parameter to specify that the width of each line in each"]
    #[doc = " plane of the YUV source image is padded to the nearest multiple of this"]
    #[doc = " number of bytes (must be a power of 2.)"]
    #[doc = ""]
    #[doc = " @param subsamp the level of chrominance subsampling used in the YUV source"]
    #[doc = " image (see @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to an image buffer that will receive the decoded"]
    #[doc = " image.  This buffer should normally be <tt>pitch * height</tt> bytes in"]
    #[doc = " size, but the <tt>dstBuf</tt> pointer can also be used to decode into a"]
    #[doc = " specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pitch bytes per line in the destination image.  Normally, this should"]
    #[doc = " be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is"]
    #[doc = " unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line"]
    #[doc = " of the destination image should be padded to the nearest 32-bit boundary, as"]
    #[doc = " is the case for Windows bitmaps.  You can also be clever and use the pitch"]
    #[doc = " parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent"]
    #[doc = " of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the destination image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjDecodeYUV(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        pad: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a set of Y, U (Cb), and V (Cr) image planes into an RGB or grayscale"]
    #[doc = " image.  This function uses the accelerated color conversion routines in the"]
    #[doc = " underlying codec but does not execute any of the other steps in the JPEG"]
    #[doc = " decompression process."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
    #[doc = ""]
    #[doc = " @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if decoding a grayscale image) that contain a YUV image"]
    #[doc = " to be decoded.  These planes can be contiguous or non-contiguous in memory."]
    #[doc = " The size of each plane should match the value returned by #tjPlaneSizeYUV()"]
    #[doc = " for the given image width, height, strides, and level of chrominance"]
    #[doc = " subsampling.  Refer to @ref YUVnotes \"YUV Image Format Notes\" for more"]
    #[doc = " details."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " line in the corresponding plane of the YUV source image.  Setting the stride"]
    #[doc = " for any plane to 0 is the same as setting it to the plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If <tt>strides</tt> is NULL, then"]
    #[doc = " the strides for all planes will be set to their respective plane widths."]
    #[doc = " You can adjust the strides in order to specify an arbitrary amount of line"]
    #[doc = " padding in each plane or to decode a subregion of a larger YUV planar image."]
    #[doc = ""]
    #[doc = " @param subsamp the level of chrominance subsampling used in the YUV source"]
    #[doc = " image (see @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to an image buffer that will receive the decoded"]
    #[doc = " image.  This buffer should normally be <tt>pitch * height</tt> bytes in"]
    #[doc = " size, but the <tt>dstBuf</tt> pointer can also be used to decode into a"]
    #[doc = " specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pitch bytes per line in the destination image.  Normally, this should"]
    #[doc = " be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is"]
    #[doc = " unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line"]
    #[doc = " of the destination image should be padded to the nearest 32-bit boundary, as"]
    #[doc = " is the case for Windows bitmaps.  You can also be clever and use the pitch"]
    #[doc = " parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent"]
    #[doc = " of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the destination image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjDecodeYUVPlanes(
        handle: tjhandle,
        srcPlanes: *mut *const ::std::os::raw::c_uchar,
        strides: *const ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new TurboJPEG transformer instance."]
    #[doc = ""]
    #[doc = " @return a handle to the newly-created instance, or NULL if an error"]
    #[doc = " occurred (see #tjGetErrorStr2().)"]
    pub fn tjInitTransform() -> tjhandle;
}
extern "C" {
    #[doc = " Losslessly transform a JPEG image into another JPEG image.  Lossless"]
    #[doc = " transforms work by moving the raw DCT coefficients from one JPEG image"]
    #[doc = " structure to another without altering the values of the coefficients.  While"]
    #[doc = " this is typically faster than decompressing the image, transforming it, and"]
    #[doc = " re-compressing it, lossless transforms are not free.  Each lossless"]
    #[doc = " transform requires reading and performing Huffman decoding on all of the"]
    #[doc = " coefficients in the source image, regardless of the size of the destination"]
    #[doc = " image.  Thus, this function provides a means of generating multiple"]
    #[doc = " transformed images from the same source or  applying multiple"]
    #[doc = " transformations simultaneously, in order to eliminate the need to read the"]
    #[doc = " source coefficients multiple times."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG transformer instance"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a buffer containing the JPEG source image to"]
    #[doc = " transform"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG source image (in bytes)"]
    #[doc = ""]
    #[doc = " @param n the number of transformed JPEG images to generate"]
    #[doc = ""]
    #[doc = " @param dstBufs pointer to an array of n image buffers.  <tt>dstBufs[i]</tt>"]
    #[doc = " will receive a JPEG image that has been transformed using the parameters in"]
    #[doc = " <tt>transforms[i]</tt>.  TurboJPEG has the ability to reallocate the JPEG"]
    #[doc = " buffer to accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set <tt>dstBufs[i]</tt> to NULL to tell TurboJPEG to allocate the buffer"]
    #[doc = " for you, or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tjBufSize() with the transformed or cropped width and height.  Under normal"]
    #[doc = " circumstances, this should ensure that the buffer never has to be"]
    #[doc = " re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)  Note,"]
    #[doc = " however, that there are some rare cases (such as transforming images with a"]
    #[doc = " large amount of embedded EXIF or ICC profile data) in which the output image"]
    #[doc = " will be larger than the worst-case size, and #TJFLAG_NOREALLOC cannot be"]
    #[doc = " used in those cases."]
    #[doc = " ."]
    #[doc = " If you choose option 1, <tt>dstSizes[i]</tt> should be set to the size of"]
    #[doc = " your pre-allocated buffer.  In any case, unless you have set"]
    #[doc = " #TJFLAG_NOREALLOC, you should always check <tt>dstBufs[i]</tt> upon return"]
    #[doc = " from this function, as it may have changed."]
    #[doc = ""]
    #[doc = " @param dstSizes pointer to an array of n unsigned long variables that will"]
    #[doc = " receive the actual sizes (in bytes) of each transformed JPEG image.  If"]
    #[doc = " <tt>dstBufs[i]</tt> points to a pre-allocated buffer, then"]
    #[doc = " <tt>dstSizes[i]</tt> should be set to the size of the buffer.  Upon return,"]
    #[doc = " <tt>dstSizes[i]</tt> will contain the size of the JPEG image (in bytes.)"]
    #[doc = ""]
    #[doc = " @param transforms pointer to an array of n #tjtransform structures, each of"]
    #[doc = " which specifies the transform parameters and/or cropping region for the"]
    #[doc = " corresponding transformed output image."]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
    #[doc = " \"flags\""]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
    #[doc = " and #tjGetErrorCode().)"]
    pub fn tjTransform(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        n: ::std::os::raw::c_int,
        dstBufs: *mut *mut ::std::os::raw::c_uchar,
        dstSizes: *mut ::std::os::raw::c_ulong,
        transforms: *mut tjtransform,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a TurboJPEG compressor, decompressor, or transformer instance."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG compressor, decompressor or"]
    #[doc = " transformer instance"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2().)"]
    pub fn tjDestroy(handle: tjhandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an image buffer for use with TurboJPEG.  You should always use"]
    #[doc = " this function to allocate the JPEG destination buffer(s) for the compression"]
    #[doc = " and transform functions unless you are disabling automatic buffer"]
    #[doc = " (re)allocation (by setting #TJFLAG_NOREALLOC.)"]
    #[doc = ""]
    #[doc = " @param bytes the number of bytes to allocate"]
    #[doc = ""]
    #[doc = " @return a pointer to a newly-allocated buffer with the specified number of"]
    #[doc = " bytes."]
    #[doc = ""]
    #[doc = " @sa tjFree()"]
    pub fn tjAlloc(bytes: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " Load an uncompressed image from disk into memory."]
    #[doc = ""]
    #[doc = " @param filename name of a file containing an uncompressed image in Windows"]
    #[doc = " BMP or PBMPLUS (PPM/PGM) format"]
    #[doc = ""]
    #[doc = " @param width pointer to an integer variable that will receive the width (in"]
    #[doc = " pixels) of the uncompressed image"]
    #[doc = ""]
    #[doc = " @param align row alignment of the image buffer to be returned (must be a"]
    #[doc = " power of 2.)  For instance, setting this parameter to 4 will cause all rows"]
    #[doc = " in the image buffer to be padded to the nearest 32-bit boundary, and setting"]
    #[doc = " this parameter to 1 will cause all rows in the image buffer to be unpadded."]
    #[doc = ""]
    #[doc = " @param height pointer to an integer variable that will receive the height"]
    #[doc = " (in pixels) of the uncompressed image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pointer to an integer variable that specifies or will"]
    #[doc = " receive the pixel format of the uncompressed image buffer.  The behavior of"]
    #[doc = " #tjLoadImage() will vary depending on the value of <tt>*pixelFormat</tt>"]
    #[doc = " passed to the function:"]
    #[doc = " - @ref TJPF_UNKNOWN : The uncompressed image buffer returned by the function"]
    #[doc = " will use the most optimal pixel format for the file type, and"]
    #[doc = " <tt>*pixelFormat</tt> will contain the ID of this pixel format upon"]
    #[doc = " successful return from the function."]
    #[doc = " - @ref TJPF_GRAY : Only PGM files and 8-bit BMP files with a grayscale"]
    #[doc = " colormap can be loaded."]
    #[doc = " - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be"]
    #[doc = " converted using a quick & dirty algorithm that is suitable only for testing"]
    #[doc = " purposes (proper conversion between CMYK and other formats requires a color"]
    #[doc = " management system.)"]
    #[doc = " - Other @ref TJPF \"pixel formats\" : The uncompressed image buffer will use"]
    #[doc = " the specified pixel format, and pixel format conversion will be performed if"]
    #[doc = " necessary."]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP"]
    #[doc = " \"flags\"."]
    #[doc = ""]
    #[doc = " @return a pointer to a newly-allocated buffer containing the uncompressed"]
    #[doc = " image, converted to the chosen pixel format and with the chosen row"]
    #[doc = " alignment, or NULL if an error occurred (see #tjGetErrorStr2().)  This"]
    #[doc = " buffer should be freed using #tjFree()."]
    pub fn tjLoadImage(
        filename: *const ::std::os::raw::c_char,
        width: *mut ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        pixelFormat: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " Save an uncompressed image from memory to disk."]
    #[doc = ""]
    #[doc = " @param filename name of a file to which to save the uncompressed image."]
    #[doc = " The image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format,"]
    #[doc = " depending on the file extension."]
    #[doc = ""]
    #[doc = " @param buffer pointer to an image buffer containing RGB, grayscale, or"]
    #[doc = " CMYK pixels to be saved"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the uncompressed image"]
    #[doc = ""]
    #[doc = " @param pitch bytes per line in the image buffer.  Setting this parameter to"]
    #[doc = " 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the uncompressed image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the image buffer (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the"]
    #[doc = " image will be stored in PGM or 8-bit (indexed color) BMP format.  Otherwise,"]
    #[doc = " the image will be stored in PPM or 24-bit BMP format.  If this parameter"]
    #[doc = " is set to @ref TJPF_CMYK, then the CMYK pixels will be converted to RGB"]
    #[doc = " using a quick & dirty algorithm that is suitable only for testing (proper"]
    #[doc = " conversion between CMYK and other formats requires a color management"]
    #[doc = " system.)"]
    #[doc = ""]
    #[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP"]
    #[doc = " \"flags\"."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2().)"]
    pub fn tjSaveImage(
        filename: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free an image buffer previously allocated by TurboJPEG.  You should always"]
    #[doc = " use this function to free JPEG destination buffer(s) that were automatically"]
    #[doc = " (re)allocated by the compression and transform functions or that were"]
    #[doc = " manually allocated using #tjAlloc()."]
    #[doc = ""]
    #[doc = " @param buffer address of the buffer to free"]
    #[doc = ""]
    #[doc = " @sa tjAlloc()"]
    pub fn tjFree(buffer: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " Returns a descriptive error message explaining why the last command failed."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG compressor, decompressor, or"]
    #[doc = " transformer instance, or NULL if the error was generated by a global"]
    #[doc = " function (but note that retrieving the error message for a global function"]
    #[doc = " is not thread-safe.)"]
    #[doc = ""]
    #[doc = " @return a descriptive error message explaining why the last command failed."]
    pub fn tjGetErrorStr2(handle: tjhandle) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a code indicating the severity of the last error.  See"]
    #[doc = " @ref TJERR \"Error codes\"."]
    #[doc = ""]
    #[doc = " @param handle a handle to a TurboJPEG compressor, decompressor or"]
    #[doc = " transformer instance"]
    #[doc = ""]
    #[doc = " @return a code indicating the severity of the last error.  See"]
    #[doc = " @ref TJERR \"Error codes\"."]
    pub fn tjGetErrorCode(handle: tjhandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TJBUFSIZE(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn TJBUFSIZEYUV(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        jpegSubsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn tjBufSizeYUV(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn tjCompress(
        handle: tjhandle,
        srcBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelSize: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        compressedSize: *mut ::std::os::raw::c_ulong,
        jpegSubsamp: ::std::os::raw::c_int,
        jpegQual: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tjEncodeYUV(
        handle: tjhandle,
        srcBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelSize: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        subsamp: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tjEncodeYUV2(
        handle: tjhandle,
        srcBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        subsamp: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tjDecompressHeader(
        handle: tjhandle,
        jpegBuf: *mut ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tjDecompressHeader2(
        handle: tjhandle,
        jpegBuf: *mut ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        jpegSubsamp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tjDecompress(
        handle: tjhandle,
        jpegBuf: *mut ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelSize: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tjDecompressToYUV(
        handle: tjhandle,
        jpegBuf: *mut ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstBuf: *mut ::std::os::raw::c_uchar,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tjGetErrorStr() -> *mut ::std::os::raw::c_char;
}
